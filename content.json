{"meta":{"title":"ZhangDaFoYe's Blog","subtitle":"","description":"","author":"ZhangDaFoYe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-03-11T11:47:24.000Z","updated":"2020-03-11T11:47:24.187Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-10T15:56:41.000Z","updated":"2020-03-10T15:58:35.037Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"我所使用的java代码技巧","slug":"我所使用的java代码技巧","date":"2020-03-10T15:41:02.000Z","updated":"2020-03-10T16:02:30.585Z","comments":true,"path":"2020/03/10/我所使用的java代码技巧/","link":"","permalink":"http://yoursite.com/2020/03/10/%E6%88%91%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84java%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/","excerpt":"","text":"Man, Glasses, Hipster, Beard, Adult 前言 罗列工作中实际使用的一些代码技巧或者叫工具类;知识无大小,希望大家都有收获 实用技巧 rpc服务出参统一化 什么,出参统一化有什么好说的????? 我不知道你们有没有遇到过多少五花八门的外部服务提供的返回对象,可能别人没有规范约束,我们管不了,但是从我们这里出去的,我们可以强制约束一下,不然发生新老交替,这代码还能看吗 首先出参都叫xxDTO的,阿里java开发手册提到过;再者我们是提供服务的一方,错误码code,错误信息msg,以及返回结果data都是要明确体现出来的,像下面这样 1public&nbsp;class&nbsp;TradeResultDTO&lt;T&gt;&nbsp;implements&nbsp;Serializable&nbsp;{ 2&nbsp;&nbsp;&nbsp;&nbsp;/** 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;默认失败编码 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/ 5&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;String&nbsp;DEFAULT_FAIL_CODE&nbsp;=&nbsp;\"500\"; 6&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;boolean&nbsp;success; 7&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;code; 8&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;msg; 9&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;T&nbsp;data;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;&lt;T&gt;&nbsp;TradeResultDTO&lt;T&gt;&nbsp;success(T&nbsp;data)&nbsp;{11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;base(\"200\",&nbsp;null,&nbsp;true,&nbsp;data);12&nbsp;&nbsp;&nbsp;&nbsp;}1314&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;&lt;T&gt;&nbsp;TradeResultDTO&lt;T&gt;&nbsp;fail(String&nbsp;code,&nbsp;String&nbsp;msg)&nbsp;{15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;base(code,&nbsp;msg,&nbsp;false,&nbsp;null);16&nbsp;&nbsp;&nbsp;&nbsp;}1718&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;&lt;T&gt;&nbsp;TradeResultDTO&lt;T&gt;&nbsp;fail(String&nbsp;msg)&nbsp;{19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;base(DEFAULT_FAIL_CODE,&nbsp;msg,&nbsp;false,&nbsp;null);20&nbsp;&nbsp;&nbsp;&nbsp;}2122&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;&lt;T&gt;&nbsp;TradeResultDTO&lt;T&gt;&nbsp;success()&nbsp;{23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;base(\"200\",&nbsp;null,&nbsp;true,&nbsp;null);24&nbsp;&nbsp;&nbsp;&nbsp;}2526&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;&lt;T&gt;&nbsp;TradeResultDTO&lt;T&gt;&nbsp;fail(IError&nbsp;iError)&nbsp;{27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;base(iError.getErrorCode(),&nbsp;iError.getErrorMsg(),&nbsp;false,&nbsp;null);28&nbsp;&nbsp;&nbsp;&nbsp;}29} 统一对象返回的结构就是上面这样 接着这个我想说的是,作为服务提供方,如果这个接口提供了返回值,我拿创建订单接口举例 1/**2&nbsp;*&nbsp;创建交易单，业务系统发起3&nbsp;*4&nbsp;*&nbsp;@param&nbsp;req&nbsp;创建入参5&nbsp;*&nbsp;@return&nbsp;返回创建信息6&nbsp;*/7TradeResultDTO&lt;TradeCreateOrderResponseDTO&gt;&nbsp;createOrder(TradeCreateOrderRequestDTO&nbsp;req)8 比如这个TradeCreateOrderResponseDTO 返回了订单号之类的基本信息,这个接口对于具体业务场景只能产生一笔订单号,我之前遇到过对方只是提示什么的错误信息(订单已存在),是的没错,他做了幂等,但是他没有返回原值,那对应的调用方进入了死循环,可能对应的业务系统,需要返回的订单号落到自己的数据库,一直异常一直回滚重试,没有任何意义;所以作为一个负责人的服务提供方,类似这种情况,如果你的方法有幂等,那么请一定返回存在的那个对象; 异常统一化 统一化使用,杜绝项目出现各种各样的自定义异常 对外统一抛出异常 我使用的统一化有两个方面: 抛出的自定义异常不要五花八门,一个就够了;很多人喜欢写各种各样的异常,初衷其实没错,但是人多手杂,自定义异常可能越写越乱; 异常信息最好尽可能的具体化,描述出业务产生异常原因就可以了,比如入参校验的用户信息不存在之类的;或者在调用用户中心的时候,捕获了该异常,此时你只需定义调用用户中心异常就可以了 然后看下工作中比较推荐的: 首先,需要搞一个统一抛出异常的工具 ExceptionUtil(这里Exceptions是公司内部统一前后端交互的,基于这个包装一个基础util,统一整个组抛异常的入口) 1public&nbsp;class&nbsp;ExceptionUtil&nbsp;{ 2&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;OptimusExceptionBase&nbsp;fail(IError&nbsp;error)&nbsp;throws&nbsp;OptimusExceptionBase&nbsp;{ 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Exceptions.fail(errorMessage(error)); 4&nbsp;&nbsp;&nbsp;&nbsp;} 5 6&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;OptimusExceptionBase&nbsp;fail(IError&nbsp;error,&nbsp;String...&nbsp;msg)&nbsp;throws&nbsp;OptimusExceptionBase&nbsp;{ 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Exceptions.fail(errorMessage(error,&nbsp;msg)); 8&nbsp;&nbsp;&nbsp;&nbsp;} 910&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;OptimusExceptionBase&nbsp;fault(IError&nbsp;error)&nbsp;throws&nbsp;OptimusExceptionBase&nbsp;{11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Exceptions.fault(errorMessage(error));12&nbsp;&nbsp;&nbsp;&nbsp;}1314&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;OptimusExceptionBase&nbsp;fault(IError&nbsp;error,&nbsp;String...&nbsp;msg)&nbsp;throws&nbsp;OptimusExceptionBase&nbsp;{15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Exceptions.fault(errorMessage(error,&nbsp;msg));16&nbsp;&nbsp;&nbsp;&nbsp;}171819&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;ErrorMessage&nbsp;errorMessage(IError&nbsp;error)&nbsp;{20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(error&nbsp;==&nbsp;null)&nbsp;{21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;CommonErrorEnum.DEFAULT_ERROR;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ErrorMessage.errorMessage(\"500\",&nbsp;\"[\"&nbsp;+&nbsp;error.getErrorCode()&nbsp;+&nbsp;\"]\"&nbsp;+&nbsp;error.getErrorMsg());24&nbsp;&nbsp;&nbsp;&nbsp;}2526&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;ErrorMessage&nbsp;errorMessage(IError&nbsp;error,&nbsp;String...&nbsp;msg)&nbsp;{27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(error&nbsp;==&nbsp;null)&nbsp;{28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;CommonErrorEnum.DEFAULT_ERROR;29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ErrorMessage.errorMessage(\"500\",&nbsp;\"[\"&nbsp;+&nbsp;error.getErrorCode()&nbsp;+&nbsp;\"]\"&nbsp;+&nbsp;MessageFormat.format(error.getErrorMsg(),&nbsp;msg));31&nbsp;&nbsp;&nbsp;&nbsp;}32} 其实上面代码里也体现出来IError这个接口了,我们的错误枚举都需要实现这个异常接口,方便统一获取对应的错误码和错误信息,这里列举一下通用异常的定义 1public&nbsp;interface&nbsp;IError&nbsp;{ 2&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;getErrorCode(); 3 4&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;getErrorMsg(); 5} 6@AllArgsConstructor 7public&nbsp;enum&nbsp;CommonErrorEnum&nbsp;implements&nbsp;IError&nbsp;{ 8&nbsp;&nbsp;&nbsp;&nbsp;/** 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/11&nbsp;&nbsp;&nbsp;&nbsp;DEFAULT_ERROR(\"00000000\",&nbsp;\"系统异常\"),12&nbsp;&nbsp;&nbsp;&nbsp;REQUEST_OBJECT_IS_NULL_ERROR(\"00000001\",&nbsp;\"入参对象为空\"),13&nbsp;&nbsp;&nbsp;&nbsp;PARAMS_CANNOT_BE_NULL_ERROR(\"00000002\",&nbsp;\"参数不能为空\"),14&nbsp;&nbsp;&nbsp;&nbsp;BUILD_LOCK_KEY_ERROR(\"00000003\",&nbsp;\"系统异常:lock&nbsp;key异常\"),15&nbsp;&nbsp;&nbsp;&nbsp;REPEAT_COMMIT_ERROR(\"00000004\",&nbsp;\"正在提交中，请稍候\");1617&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;code;18&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;msg;1920&nbsp;&nbsp;&nbsp;&nbsp;@Override21&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getErrorCode()&nbsp;{22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;code;23&nbsp;&nbsp;&nbsp;&nbsp;}2425&nbsp;&nbsp;&nbsp;&nbsp;@Override26&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getErrorMsg()&nbsp;{27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;msg;28&nbsp;&nbsp;&nbsp;&nbsp;}29} 类似上面CommonErrorEnum的方式我们可以按照具体业务定义相应的枚举,比如OrderErrorEnum、PayErrorEnum之类,不仅具有区分度而且,也能瞬速定位问题; 所以对外抛出异常统一化就一把梭:统一util和业务错误枚举分类 对内统一捕获外部异常 很多时候我们需要调用别人的服务然后写了一些adapter适配类,然后在里面trycatch一把;其实这时候可以利用aop好好搞一把就完事了,并且统一输出adapter层里面的日志 1&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Object&nbsp;transferException(ProceedingJoinPoint&nbsp;joinPoint)&nbsp;{ 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{ 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;result&nbsp;=&nbsp;joinPoint.proceed(); 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info(\"adapter&nbsp;result:{}\",&nbsp;JSON.toJSONString(result)); 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Throwable&nbsp;exception)&nbsp;{ 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodSignature&nbsp;signature&nbsp;=&nbsp;(MethodSignature)&nbsp;joinPoint.getSignature(); 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;method&nbsp;=&nbsp;signature.getMethod(); 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(\"{}.{}&nbsp;throw&nbsp;exception\",&nbsp;method.getDeclaringClass().getName(),&nbsp;method.getName(),&nbsp;exception);10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;ExceptionUtils.fault(CommonErrorEnum.ADAPTER_SERVICE_ERROR);11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}13&nbsp;&nbsp;&nbsp;&nbsp;} 上面这段统一捕获了外部服务,记录异常日志,避免了每个adapter类重复捕获的问题 参数校验 用过swagger的应该了解api方法里有对应的注解属性约束是否必填项,但是如果判断不是在api入口又或者没有类似的注解,你们一般怎么做的,下面给出我自己的一种简单工具;有更好大佬的可以推荐一下 ParamCheckUtil.java 1@Slf4j 2public&nbsp;class&nbsp;ParamCheckUtil&nbsp;{ 3 4&nbsp;&nbsp;&nbsp;&nbsp;/** 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;校验请求参数是否为空 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;requestParams&nbsp;请求入参 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属性值数组 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/10&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;checkParams(Object&nbsp;requestParams,&nbsp;String...&nbsp;keys)&nbsp;{11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(null&nbsp;==&nbsp;requestParams)&nbsp;{12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;ExceptionUtil.fault(CommonErrorEnum.REQUEST_OBJECT_IS_NULL_ERROR);13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuilder&nbsp;sb&nbsp;=&nbsp;new&nbsp;StringBuilder();15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(String&nbsp;fieldName&nbsp;:&nbsp;keys)&nbsp;{16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;value&nbsp;=&nbsp;null;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;type&nbsp;=&nbsp;null;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;firstLetter&nbsp;=&nbsp;fieldName.substring(0,&nbsp;1).toUpperCase();20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;getter&nbsp;=&nbsp;\"get\"&nbsp;+&nbsp;firstLetter&nbsp;+&nbsp;fieldName.substring(1);21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;method&nbsp;=&nbsp;requestParams.getClass().getMethod(getter);22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;method.invoke(requestParams);23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;method.getReturnType();24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(\"获取属性值出错，requestParams={},&nbsp;fieldName={}\",&nbsp;requestParams,&nbsp;fieldName);26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;判空标志&nbsp;String/Collection/Map特殊处理28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;isEmpty&nbsp;=29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(String.class&nbsp;==&nbsp;type&nbsp;&amp;&amp;&nbsp;StringUtil.isEmpty((String)&nbsp;value))30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;(Collection.class&nbsp;==&nbsp;type&nbsp;&amp;&amp;&nbsp;CollectionUtils.isEmpty((Collection&lt;?&nbsp;extends&nbsp;Object&gt;)&nbsp;value))31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;(Map.class&nbsp;==&nbsp;type&nbsp;&amp;&amp;&nbsp;CollectionUtils.isEmpty((Collection&lt;?&nbsp;extends&nbsp;Object&gt;)&nbsp;value))32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;(null&nbsp;==&nbsp;value);33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isEmpty)&nbsp;{34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sb.length()&nbsp;!=&nbsp;0)&nbsp;{35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(\",\");36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(fieldName);38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}4142&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sb.length()&nbsp;&gt;&nbsp;0)&nbsp;{43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.error(sb.toString()&nbsp;+&nbsp;CommonErrorEnum.PARAMS_CANNOT_BE_NULL_ERROR.getErrorMsg());44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;ExceptionUtil.fault(CommonErrorEnum.PARAMS_CANNOT_BE_NULL_ERROR,&nbsp;sb.toString()&nbsp;+&nbsp;CommonErrorEnum.PARAMS_CANNOT_BE_NULL_ERROR.getErrorMsg());45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}46&nbsp;&nbsp;&nbsp;&nbsp;}4748&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;test49&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TradeCreateOrderRequestDTO&nbsp;tradeCreateOrderRequestDTO&nbsp;=&nbsp;new&nbsp;TradeCreateOrderRequestDTO();51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tradeCreateOrderRequestDTO.setBusinessNo(\"\");52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ParamCheckUtil.checkParams(tradeCreateOrderRequestDTO,&nbsp;\"businessNo\",&nbsp;\"tradeType\",&nbsp;\"tradeItemDTOS\");53&nbsp;&nbsp;&nbsp;&nbsp;}5455} 基于了上面统一异常的形式,只要参数校验出空我就抛出异常中断程序,并且告知其缺什么参数 我在业务代码需要判断字段非空的地方只需要一行就够了,就行下面这样 1ParamCheckUtil.checkParams(tradeCreateOrderRequestDTO,&nbsp;\"businessNo\",&nbsp;\"tradeType\",&nbsp;\"tradeItemDTOS\"); 而不是我们常用的一堆判断,像下面这样;看到这些我人都晕了,一次两次就算了,一大段全是这种 1if&nbsp;(null&nbsp;==&nbsp;tradeCreateOrderRequestDTO)&nbsp;{ 2//&nbsp;提示tradeCreateOrderRequestDTO为空 3} 4if&nbsp;(StringUtil.isEmpty(tradeCreateOrderRequestDTO.getBusinessNo()))&nbsp;{ 5//&nbsp;提示businessNo为空 6} 7if&nbsp;(StringUtil.isEmpty(tradeCreateOrderRequestDTO.getTradeType()))&nbsp;{ 8//&nbsp;提示tradeType为空 9}10if&nbsp;(CollectionUtils.isEmpty(tradeCreateOrderRequestDTO.getTradeItemDTOS()))&nbsp;{11//&nbsp;提示tradeItemDTOS列表为空12} 如果你是上面说的这种形式,不妨试试我提供的这种 bean相关 对象的构造 关于对象的构造,我想提两点,构造变的对象和不变的对象 构造不变对象,使用builder,不提供set方法,推荐使用lombok @Builder 1@Builder2public&nbsp;class&nbsp;UserInfo&nbsp;{3&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;id;4&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;56&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserInfo&nbsp;userInfo&nbsp;=&nbsp;UserInfo.builder().id(\"a\").name(\"name\").build();8&nbsp;&nbsp;&nbsp;&nbsp;}9} 构造可变对象,推荐提供链式调用形式 使用lombok @Accessors(chain = true)注解 1@Data2@Accessors(chain&nbsp;=&nbsp;true)3public&nbsp;class&nbsp;CardInfo&nbsp;{4&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;id;5&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;6&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CardInfo&nbsp;cardInfo&nbsp;=&nbsp;new&nbsp;CardInfo().setId(\"c\").setName(\"name\");8&nbsp;&nbsp;&nbsp;&nbsp;}9} 对象转换 就一把梭:lambda工具类+mapstruct进行转换 BeanConvertUtil.java 通用的对象、list、Page转换 1public&nbsp;class&nbsp;BeanConvertUtil&nbsp;{ 2&nbsp;&nbsp;&nbsp;&nbsp;/** 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;对象转换 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源对象 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;convertFun&nbsp;T&nbsp;-&gt;&nbsp;R&nbsp;lambda转换表达式 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;&lt;T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入类型 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;&lt;R&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出类型 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;返回转化后输出类型的对象10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/11&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;&lt;T,&nbsp;R&gt;&nbsp;R&nbsp;convertObject(T&nbsp;source,&nbsp;Function&lt;T,&nbsp;R&gt;&nbsp;convertFun)&nbsp;{12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(null&nbsp;==&nbsp;source)&nbsp;{13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;convertFun.apply(source);16&nbsp;&nbsp;&nbsp;&nbsp;}1718&nbsp;&nbsp;&nbsp;&nbsp;/**19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Page转换20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;page&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源对象22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;convertFun&nbsp;T&nbsp;-&gt;&nbsp;R&nbsp;lambda转换表达式23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;&lt;T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入类型24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;&lt;R&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出类型25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;返回转化后输出类型的对象26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/27&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;&lt;T,&nbsp;R&gt;&nbsp;Page&lt;R&gt;&nbsp;convertPage(Page&lt;T&gt;&nbsp;page,&nbsp;Function&lt;T,&nbsp;R&gt;&nbsp;convertFun)&nbsp;{28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Objects.isNull(page))&nbsp;{29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Page&lt;&gt;(0,&nbsp;1,&nbsp;10,&nbsp;Collections.emptyList());30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;R&gt;&nbsp;pageList&nbsp;=&nbsp;convertList(page.getItems(),&nbsp;convertFun);32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;Page&lt;&gt;(page.getTotalNumber(),&nbsp;page.getCurrentIndex(),&nbsp;page.getPageSize(),&nbsp;pageList);33&nbsp;&nbsp;&nbsp;&nbsp;}3435&nbsp;&nbsp;&nbsp;&nbsp;/**36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;ListData转换37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;inputList&nbsp;&nbsp;数据源39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;convertFun&nbsp;T&nbsp;-&gt;&nbsp;R&nbsp;lambda转换表达式40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;&lt;T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入类型41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;&lt;R&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出类型42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;输出43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/44&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;&lt;T,&nbsp;R&gt;&nbsp;List&lt;R&gt;&nbsp;convertList(List&lt;T&gt;&nbsp;inputList,&nbsp;Function&lt;T,&nbsp;R&gt;&nbsp;convertFun)&nbsp;{45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(org.springframework.util.CollectionUtils.isEmpty(inputList))&nbsp;{46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Lists.newArrayList();47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inputList49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.stream()50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(convertFun)51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.collect(Collectors.toList());52&nbsp;&nbsp;&nbsp;&nbsp;}53} 实战使用,在lambda方法进行转换: 先转换相同属性,再进行剩余属性赋值 1&nbsp;public&nbsp;interface&nbsp;OrderConverter&nbsp;{ 2&nbsp;&nbsp;&nbsp;&nbsp;OrderConverter&nbsp;INSTANCE&nbsp;=&nbsp;Mappers.getMapper(OrderConverter.class); 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;入参进行相同属性转换 4&nbsp;&nbsp;&nbsp;&nbsp;TradeOrderDO&nbsp;createOrder2TradeOrderDO(TradeCreateOrderRequestDTO&nbsp;req); 5} 6&nbsp;TradeOrderDO&nbsp;mainTradeOrder&nbsp;=&nbsp;BeanConvertUtil.convertObject(req,&nbsp;x&nbsp;-&gt;&nbsp;{ 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TradeOrderDO&nbsp;tod&nbsp;=&nbsp;OrderConverter.INSTANCE.createOrder2TradeOrderDO(req); 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tod.setOrderType(mainOrderType); 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tod.setOrderCode(snowflakeIdAdapterService.getId());10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tod.setOrderStatus(TradeStateEnum.ORDER_CREATED.getValue());11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tod.setDateCreate(new&nbsp;Date());12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tod.setDateUpdate(new&nbsp;Date());13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;tod;14}); 其实对象转换也可以完全通过mapstruct提供的一些表达式进行转换,但是有时候写那个感觉不是很直观,其实都可以,我比较喜欢我这种形式,大家有建议也可以提出 NPE解决指南 1.null值手动判断[强制] 嵌套取值&lt;3 推荐 null值判断(PS:强制null写在前面,别问为什么,问就是这样写你会意识到这里要NPE) 学会这点 基本意识有了 1null!=obj&amp;&amp;null!=obj.getXX() 2.Optional 2.1 Optional嵌套取值[强制] 参数&gt;=3的取值操作学会这点 基本告别NPE 这里以OrderInfo对象为例 获取purchaseType 1Optional&lt;OrderInfo&gt;&nbsp;optional&nbsp;=&nbsp;Optional.ofNullable(dto);2Integer&nbsp;purchaseType&nbsp;=&nbsp;optional.map(OrderInfo::getOrderCarDTO)3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.map(OrderCarDTO::getPurchaseType)4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.orElse(null); 如果对取出的值如需再次进行判断操作 参考第1点 2.2 中断抛出异常[按需] 还是以上面的例子 1{2&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...3&nbsp;&nbsp;&nbsp;&nbsp;optional.map(OrderInfo::getOrderDTO).map(OrderDTO::getOrderBusinessType)4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.orElseThrow(()&nbsp;-&gt;&nbsp;new&nbsp;Exception(\"获取cityCode失败\"));5} 如果依赖某些值,可尽早fail-fast 3.对象判空[强制] 1Objects.equals(obj1,obj2); 4.Boolean值判断[强制] 弃用以下方式谢谢(PS:很多时候null判断你会丢的) 1null!=a&amp;&amp;a; 正确食用 1Boolean.TRUE.equals(a); 5.list正确判空姿势[强制] 1if&nbsp;(CollectionUtils.isEmpty(list))&nbsp;{2&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;fail&nbsp;fast3&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;return&nbsp;xxObj&nbsp;or&nbsp;return;4}5List&lt;Object&gt;&nbsp;safeList&nbsp;=&nbsp;list.stream().filter(Objects::nonNull).collect(Collectors.toList());6if&nbsp;(CollectionUtils.isEmpty(safeList))&nbsp;{7&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;fail&nbsp;fast8&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;return&nbsp;xxObj&nbsp;or&nbsp;return;9} 6.String正确判空姿势[强制] 1//&nbsp;不为空2if&nbsp;(StringUtil.isNotEmpty(s))&nbsp;{3&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...4} 7.包装类型转换判空[强制] 特别是遍历过程中使用，需要判断是否为空。 1int&nbsp;i&nbsp;=&nbsp;0;2list.forEach(item&nbsp;-&gt;&nbsp;{3&nbsp;&nbsp;&nbsp;&nbsp;if(Objects.nonNull(item.getType)){4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;+=&nbsp;item.getType;&nbsp;//item.getType&nbsp;返回&nbsp;Integer&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;}6}); 小结 融会贯通以上几招绝对告别NPE END 未完待续,大家如果有好的建议,希望在留言中提出","categories":[{"name":"java技术","slug":"java技术","permalink":"http://yoursite.com/categories/java%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]}]}